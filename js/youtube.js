let KEYWORDS = [];
let ENABLE = true;
let REGEXES = [];

const BACKDROP_CLASSNAME = "a3r545t44t5_no_spoiler_backdrop";

const HOME_SCREEN_TAG = "ytd-rich-item-renderer";
const SEARCH_SCREEN_TAG = "ytd-video-renderer";
const VIDEO_SCREEN_TAG = "ytd-compact-video-renderer";

const VISIBLE_ICON = `<!-- Generated by IcoMoon.io -->
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
<title>Hide Video Card</title>
<path fill="inherit" d="M16 6c-6.979 0-13.028 4.064-16 10 2.972 5.936 9.021 10 16 10s13.027-4.064 16-10c-2.972-5.936-9.021-10-16-10zM23.889 11.303c1.88 1.199 3.473 2.805 4.67 4.697-1.197 1.891-2.79 3.498-4.67 4.697-2.362 1.507-5.090 2.303-7.889 2.303s-5.527-0.796-7.889-2.303c-1.88-1.199-3.473-2.805-4.67-4.697 1.197-1.891 2.79-3.498 4.67-4.697 0.122-0.078 0.246-0.154 0.371-0.228-0.311 0.854-0.482 1.776-0.482 2.737 0 4.418 3.582 8 8 8s8-3.582 8-8c0-0.962-0.17-1.883-0.482-2.737 0.124 0.074 0.248 0.15 0.371 0.228v0zM16 13c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3z"></path>
</svg>
`;
const HIDDEN_ICON = `<!-- Generated by IcoMoon.io -->
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
<title>Show Video Card</title>
<path fill="inherit" d="M29.561 0.439c-0.586-0.586-1.535-0.586-2.121 0l-6.318 6.318c-1.623-0.492-3.342-0.757-5.122-0.757-6.979 0-13.028 4.064-16 10 1.285 2.566 3.145 4.782 5.407 6.472l-4.968 4.968c-0.586 0.586-0.586 1.535 0 2.121 0.293 0.293 0.677 0.439 1.061 0.439s0.768-0.146 1.061-0.439l27-27c0.586-0.586 0.586-1.536 0-2.121zM13 10c1.32 0 2.44 0.853 2.841 2.037l-3.804 3.804c-1.184-0.401-2.037-1.521-2.037-2.841 0-1.657 1.343-3 3-3zM3.441 16c1.197-1.891 2.79-3.498 4.67-4.697 0.122-0.078 0.246-0.154 0.371-0.228-0.311 0.854-0.482 1.776-0.482 2.737 0 1.715 0.54 3.304 1.459 4.607l-1.904 1.904c-1.639-1.151-3.038-2.621-4.114-4.323z"></path>
<path fill="inherit" d="M24 13.813c0-0.849-0.133-1.667-0.378-2.434l-10.056 10.056c0.768 0.245 1.586 0.378 2.435 0.378 4.418 0 8-3.582 8-8z"></path>
<path fill="inherit" d="M25.938 9.062l-2.168 2.168c0.040 0.025 0.079 0.049 0.118 0.074 1.88 1.199 3.473 2.805 4.67 4.697-1.197 1.891-2.79 3.498-4.67 4.697-2.362 1.507-5.090 2.303-7.889 2.303-1.208 0-2.403-0.149-3.561-0.439l-2.403 2.403c1.866 0.671 3.873 1.036 5.964 1.036 6.978 0 13.027-4.064 16-10-1.407-2.81-3.504-5.2-6.062-6.938z"></path>
</svg>
`;

function matches(text) {
  if (!text) return false;
  for (let regex of REGEXES) {
    if (text.search(regex) != -1) {
      return true;
    }
  }
  return false;
}

function cleanText(text) {
  if (!text) return text;
  if (typeof text === "string" || text instanceof String) {
    return text.replace("\n", "").replace(/\s+/gim, " ");
  }
  return text;
}

function createToogleVisibilityButton(parentElement) {
  let button = document.createElement("button");
  button.style.background = "transparent";
  button.style.border = "none";
  button.style.color = "darkgrey";
  button.style.fill = "darkgrey";
  button.style.cursor = "help";
  button.style.pointerEvents = "all";
  let isHidden = parentElement.style.backdropFilter === "blur(20px)";
  if (isHidden) {
    button.innerHTML = HIDDEN_ICON;
  } else {
    button.innerHTML = VISIBLE_ICON;
  }
  button.addEventListener("click", (ev) => {
    let parent = button.parentElement;
    let hidden = parent?.style.backdropFilter === "blur(20px)";
    if (hidden) {
      parent.style.backdropFilter = "none";
      ev.target.innerHTML = VISIBLE_ICON;
      parent.style.pointerEvents = "none";
    } else {
      parent.style.backdropFilter = "blur(20px)";
      ev.target.innerHTML = HIDDEN_ICON;
      parent.style.pointerEvents = "all";
    }
  });
  return button;
}

function newBackdropElement() {
  let element = document.createElement("div");
  element.className = BACKDROP_CLASSNAME;
  element.style.position = "absolute";
  element.style.top = 0;
  element.style.left = 0;
  element.style.width = "100%";
  element.style.height = "100%";
  element.style.backdropFilter = "blur(20px)";
  element.style.zIndex = 500;
  element.style.display = "flex";
  element.style.alignItems = "center";
  element.style.pointerEvents = "all";
  element.style.justifyContent = "center";
  let button = createToogleVisibilityButton(element);
  element.appendChild(button);
  return element;
}

function blockElement(element) {
  if (!element) {
    return;
  }
  if (!ENABLE) {
    return;
  }
  let channelName = element.querySelector("#channel-name a");
  channelName =
    channelName?.textContent || channelName?.text || channelName?.title;
  channelName = cleanText(channelName);
  let videoTitle = element.querySelector("#video-title");
  videoTitle = videoTitle?.textContent || videoTitle?.text || videoTitle?.title;
  videoTitle = cleanText(videoTitle);
  if (!videoTitle) return;
  let match = matches(videoTitle) || matches(channelName);
  let existingBackdrop = element.querySelector(`.${BACKDROP_CLASSNAME}`);
  if (existingBackdrop && !match) {
    existingBackdrop.remove();
  }
  if (!match || existingBackdrop) return;
  console.warn(`Blocking ${channelName} : ${videoTitle}`);
  let backdrop = newBackdropElement();
  element.appendChild(backdrop);
}

const targetNode = document;

const observerConfig = {
  childList: true,
  subtree: true,
  attributeOldValue: true,
};

function completeExistingContent() {
  let homeElements = document.getElementsByTagName(HOME_SCREEN_TAG);
  let searchElements = document.getElementsByTagName(SEARCH_SCREEN_TAG);
  let watchingElements = document.getElementsByTagName(VIDEO_SCREEN_TAG);
  Array.from(homeElements).forEach((element) => blockElement(element));
  Array.from(searchElements).forEach((element) => blockElement(element));
  Array.from(watchingElements).forEach((element) => blockElement(element));
}

const observer = new MutationObserver((mutations, observer) => {
  if (!ENABLE) return;
  completeExistingContent();
});

function reset() {
  let elements = document.querySelectorAll(`.${BACKDROP_CLASSNAME}`);
  Array.from(elements).forEach((element) => element.remove());
  completeExistingContent();
}

function update(keywords, enabled) {
  KEYWORDS = keywords;
  ENABLE = enabled;
  REGEXES = KEYWORDS.map((keyword) => {
    let regex = keyword.replace(/[^\w\d\s]/gim, ".*");
    regex = regex.replace(/\s+/gim, "\\s*");
    regex = regex.replace(/\d+/gim, "\\d+");
    return new RegExp(regex, "im");
  });
  reset();
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.type === "state_sync") {
    sendResponse(true);
    update(request.value.keywords, request.value.enabled);
  } else {
    sendResponse({ error: "Unknown request type" });
  }
});

function fetchState() {
  chrome.runtime.sendMessage(
    {
      type: "tab_reg",
    },
    (response) => {
      console.warn(response);
    }
  );
}

fetchState();

observer.observe(targetNode, observerConfig);
